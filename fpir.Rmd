Functional Programming in R
===========================


Aims of this tutorial
---------------------

1. Write a _very bad_ imperative function
2. Split into clean and dirty functions
3. Get rid of any loops
4. Set up for parallel processing
5. Compare efficiency


So, first an R function to do the following:

* Build a load of big matrices and fill them with random numbers
* Sequentially multiply them together using linear algebra
* Decompose using PCA
* Plot the first two principal components

```{r}

vcv <- matrix(c(1.0,0.1,0.8,0.9,0.8,
                0.01,1.0,0.01,0.01,0.01,
                0.8,0.01,1.0,0.6,0.6,
                0.9,0.01,0.6,1.0,0.9,
                0.8,0.01,0.6,0.9,1.0), nrow = 5, byrow = TRUE)

samp_list <- list()
for(i in 1:10){
  m <- sample(10,1) + rnorm(1)
  samp_list[[i]] <- data.frame(mvrnorm(n=200, mu = rep(m,5), Sigma=vcv))
  samp_list[[i]]$location <- paste("location", i,sep="_")
  samp_list[[i]]$family <- paste("1_",rep(1:20, 10), sep = "")
  
}

samp_stack <- samp_list[[1]]
for(j in 2:length(samp_list)){
  samp_stack <- rbind(samp_stack, samp_list[[j]])
  

}

# wrong from here...

names(samp_stack) <- c("height", "length", "width", "weight", "starch", "location")
samp_starch <- rep(samp_stack$starch, 4)
samp_stack$starch <- NULL
samp_stack$location <- factor(samp_stack$location)
samp_melt <- melt(samp_stack, variable.name = "trait")
samp_melt$starch <- samp_starch

Y = with(samp_stack)
mod <- lmer(value ~ (trait| value) + (1|location), data = samp_melt)
summary(mod)
gpairs(samp_stack[,1:5], upper.pars = list(scatter = "stats"), lower.pars = list(scatter = "loess"))

pca <- prcomp(x)

```


```{r}
plot_random_mats_imp <- function(out_file = ""){
  mat_list <- list()
  tree <- rtree(12)
  dm <- cophenetic(tree)
  thetas <-c(2, 1* max(cophenetic(tree)),0.1)
  tips_mat <- matrix(nrow = 12, ncol = 1000)
  for(i in 1:1000){
    tips_mat[,i] <- phylogenetic_noise(thetas, dm)
  }
  gpairs(tips_mat[,1:15], upper.pars = list(scatter = "stats"), lower.pars = list(scatter = "loess"))
dist(tips_mat)
  fit <- hclust(d, method="ward") 
plot(fit) # display dendogram
  mean_tips <- c()
  
  mat_list
  big_mat <- mat_list[[1]]
  for(j in 2:length(mat_list)){
    big_mat <- big_mat %*% mat_list[[j]]
  }
  big_pca <- prcomp(tips_mat)
  
  }
```

You can also embed plots, for example:

```{r fig.width=7, fig.height=6}
plot(cars)
```

